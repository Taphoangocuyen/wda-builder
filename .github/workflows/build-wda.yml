name: Build WDA PATH for TrollStore

on:
  workflow_dispatch:
    inputs:
      bundle_id:
        description: 'Bundle ID for WDA'
        required: false
        default: 'com.facebook.WebDriverAgentRunner'
      display_name:
        description: 'App display name'
        required: false
        default: 'iPhone-Control'
      auth_key:
        description: 'IPC Auth Key (leave empty to use repository secret IPC_AUTH_KEY)'
        required: false
        default: ''

jobs:
  build:
    runs-on: macos-14
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Clone WebDriverAgent source
        run: |
          git clone https://github.com/appium/WebDriverAgent.git
          cd WebDriverAgent
          echo "WDA version: $(git describe --tags --always)"

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      # IPC Auth Guard ‚Äî compile as static library
      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      - name: Build IPC Auth Guard
        run: |
          # Determine auth key: input > secret > skip
          AUTH_KEY="${{ github.event.inputs.auth_key }}"
          if [ -z "$AUTH_KEY" ]; then
            AUTH_KEY="${{ secrets.IPC_AUTH_KEY }}"
          fi

          if [ -z "$AUTH_KEY" ]; then
            echo "‚ö†Ô∏è No auth key provided ‚Äî building WITHOUT auth protection"
            echo "AUTH_ENABLED=false" >> $GITHUB_ENV
          else
            echo "‚úÖ Auth key found (${#AUTH_KEY} chars) ‚Äî building WITH auth protection"
            echo "AUTH_ENABLED=true" >> $GITHUB_ENV

            # Generate route prefix from auth key (first 8 chars)
            ROUTE_PREFIX="ipc_${AUTH_KEY:0:8}"
            echo "  Route prefix: $ROUTE_PREFIX"

            # Replace placeholders in source
            sed -i '' "s|__IPC_AUTH_KEY__|${AUTH_KEY}|g" src/IPCAuthGuard.m
            sed -i '' "s|__IPC_ROUTE_PREFIX__|${ROUTE_PREFIX}|g" src/IPCAuthGuard.m

            # Get iOS SDK path
            IOS_SDK=$(xcrun --sdk iphoneos --show-sdk-path)

            # Compile ObjC ‚Üí object file (arm64 only)
            clang -c -arch arm64 \
              -isysroot "$IOS_SDK" \
              -miphoneos-version-min=15.0 \
              -fobjc-arc \
              -fmodules \
              -o IPCAuthGuard.o \
              src/IPCAuthGuard.m

            # Create static library
            ar rcs libIPCAuth.a IPCAuthGuard.o

            echo "=== Auth guard compiled ==="
            ls -lh libIPCAuth.a
          fi

      - name: Build WebDriverAgent for iOS (arm64)
        run: |
          cd WebDriverAgent

          # Extra linker flags if auth is enabled
          EXTRA_LDFLAGS=""
          if [ "$AUTH_ENABLED" = "true" ]; then
            EXTRA_LDFLAGS="-lIPCAuth -L${{ github.workspace }} -ObjC"
            echo "üîê Linking with IPC Auth Guard"
          fi

          xcodebuild build-for-testing \
            -project WebDriverAgent.xcodeproj \
            -scheme WebDriverAgentRunner \
            -destination 'generic/platform=iOS' \
            -configuration Release \
            -derivedDataPath build \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            PRODUCT_BUNDLE_IDENTIFIER="${{ github.event.inputs.bundle_id }}" \
            DEVELOPMENT_TEAM="" \
            ARCHS=arm64 \
            ONLY_ACTIVE_ARCH=NO \
            OTHER_LDFLAGS="\$(inherited) $EXTRA_LDFLAGS"

          echo "=== Build completed ==="

      - name: Package TrollStore-compatible IPA
        run: |
          BUNDLE_ID="${{ github.event.inputs.bundle_id }}"
          DISPLAY_NAME="${{ github.event.inputs.display_name }}"

          # Find the built .app
          APP_PATH=$(find WebDriverAgent/build -name "WebDriverAgentRunner-Runner.app" -type d | head -1)
          echo "Found app at: $APP_PATH"

          if [ -z "$APP_PATH" ]; then
            echo "ERROR: WebDriverAgentRunner-Runner.app not found!"
            find WebDriverAgent/build -name "*.app" -type d
            exit 1
          fi

          # Create Payload directory
          mkdir -p Payload
          cp -R "$APP_PATH" Payload/

          TARGET_APP="Payload/WebDriverAgentRunner-Runner.app"

          # === List all files for debugging ===
          echo "=== App contents ==="
          find "$TARGET_APP" -type f

          # === Custom App Icon ===
          if [ -f "resources/icon.png" ]; then
            echo "=== Setting custom app icon ==="
            # Generate iOS icon sizes from source
            sips -z 120 120 resources/icon.png --out "$TARGET_APP/AppIcon60x60@2x.png" 2>/dev/null || true
            sips -z 180 180 resources/icon.png --out "$TARGET_APP/AppIcon60x60@3x.png" 2>/dev/null || true
            sips -z 152 152 resources/icon.png --out "$TARGET_APP/AppIcon76x76@2x.png" 2>/dev/null || true
            sips -z 167 167 resources/icon.png --out "$TARGET_APP/AppIcon83.5x83.5@2x.png" 2>/dev/null || true
            # Also copy as icon.png fallback
            cp resources/icon.png "$TARGET_APP/icon.png"

            # Set CFBundleIcons in Info.plist
            /usr/libexec/PlistBuddy -c "Delete :CFBundleIcons" "$TARGET_APP/Info.plist" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :CFBundleIcons dict" "$TARGET_APP/Info.plist"
            /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon dict" "$TARGET_APP/Info.plist"
            /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles array" "$TARGET_APP/Info.plist"
            /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles:0 string AppIcon60x60" "$TARGET_APP/Info.plist"
            /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles:1 string AppIcon76x76" "$TARGET_APP/Info.plist"
            /usr/libexec/PlistBuddy -c "Add :CFBundleIcons:CFBundlePrimaryIcon:CFBundleIconFiles:2 string AppIcon83.5x83.5" "$TARGET_APP/Info.plist"
            echo "  App icon set from resources/icon.png"
          else
            echo "  No custom icon found, using default WDA icon"
          fi

          # === Patch Info.plist ===
          /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName '$DISPLAY_NAME'" "$TARGET_APP/Info.plist" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :CFBundleDisplayName string '$DISPLAY_NAME'" "$TARGET_APP/Info.plist"

          /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier '${BUNDLE_ID}.xctrunner'" "$TARGET_APP/Info.plist"

          # Update xctest bundle ID
          XCTEST_DIR=$(find "$TARGET_APP/PlugIns" -name "*.xctest" -type d | head -1)
          if [ -n "$XCTEST_DIR" ]; then
            /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier '$BUNDLE_ID'" "$XCTEST_DIR/Info.plist" 2>/dev/null || true
          fi

          # === Self-launch config for TrollStore ===
          echo "=== Configuring for TrollStore self-launch ==="
          PLIST="$TARGET_APP/Info.plist"

          # Allow launch from SpringBoard
          /usr/libexec/PlistBuddy -c "Set :SBIsLaunchableDuringSetup true" "$PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :SBIsLaunchableDuringSetup bool true" "$PLIST"

          # Full screen
          /usr/libexec/PlistBuddy -c "Set :UIRequiresFullScreen true" "$PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :UIRequiresFullScreen bool true" "$PLIST"

          # Background mode
          /usr/libexec/PlistBuddy -c "Delete :UIBackgroundModes" "$PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes array" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :UIBackgroundModes:0 string continuous" "$PLIST"

          # Device family (iPhone + iPad)
          /usr/libexec/PlistBuddy -c "Delete :UIDeviceFamily" "$PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :UIDeviceFamily array" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :UIDeviceFamily:0 integer 1" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :UIDeviceFamily:1 integer 2" "$PLIST"

          # Allow HTTP connections
          /usr/libexec/PlistBuddy -c "Delete :NSAppTransportSecurity" "$PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :NSAppTransportSecurity dict" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :NSAppTransportSecurity:NSAllowsArbitraryLoads bool true" "$PLIST"

          # Network permission
          /usr/libexec/PlistBuddy -c "Set :NSLocalNetworkUsageDescription 'Required for device control'" "$PLIST" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :NSLocalNetworkUsageDescription string 'Required for device control'" "$PLIST"

          echo "  Self-launch config applied"

          # === Remove all code signatures ===
          echo "=== Removing code signatures ==="
          find Payload -name "_CodeSignature" -type d -exec rm -rf {} + 2>/dev/null || true
          find Payload -name "embedded.mobileprovision" -delete 2>/dev/null || true
          find Payload -name "*.dSYM" -type d -exec rm -rf {} + 2>/dev/null || true

          # === Patch MH_BUNDLE to MH_DYLIB (Frameworks ONLY) ===
          # CH√ö √ù: Ch·ªâ patch file trong Frameworks/, KH√îNG patch xctest binary
          # v√¨ xctest binary kh√¥ng c√≥ LC_ID_DYLIB ‚Üí dyld crash khi load
          echo "=== Patching Mach-O binaries (Frameworks only) ==="
          python3 << 'PYEOF'
          import struct, os

          def get_macho_info(filepath):
              try:
                  with open(filepath, 'rb') as f:
                      data = f.read(32)
                  if len(data) < 16:
                      return None
                  magic = struct.unpack_from('<I', data, 0)[0]
                  if magic in (0xfeedfacf, 0xfeedface, 0xbebafeca, 0xcafebabe):
                      return magic
                  return None
              except:
                  return None

          def patch_bundle_to_dylib(filepath):
              with open(filepath, 'rb') as f:
                  data = bytearray(f.read())

              magic = struct.unpack_from('<I', data, 0)[0]
              patched = False
              fname = os.path.basename(filepath)

              if magic in (0xfeedfacf, 0xfeedface):
                  ft = struct.unpack_from('<I', data, 12)[0]
                  print(f"  [{fname}] FileType: {ft}")
                  if ft == 8:
                      struct.pack_into('<I', data, 12, 6)
                      patched = True
                      print(f"  [{fname}] PATCHED: MH_BUNDLE -> MH_DYLIB")

              elif magic in (0xbebafeca, 0xcafebabe):
                  nfat = struct.unpack_from('>I', data, 4)[0]
                  print(f"  [{fname}] FAT binary with {nfat} slices")
                  for i in range(nfat):
                      entry_offset = 8 + i * 20
                      slice_offset = struct.unpack_from('>I', data, entry_offset + 8)[0]
                      slice_magic = struct.unpack_from('<I', data, slice_offset)[0]
                      if slice_magic in (0xfeedfacf, 0xfeedface):
                          ft = struct.unpack_from('<I', data, slice_offset + 12)[0]
                          if ft == 8:
                              struct.pack_into('<I', data, slice_offset + 12, 6)
                              patched = True
                              print(f"  [{fname}] Slice {i} PATCHED: MH_BUNDLE -> MH_DYLIB")

              if patched:
                  with open(filepath, 'wb') as f:
                      f.write(data)
              return patched

          total_patched = 0
          for root, dirs, files in os.walk("Payload"):
              for fname in files:
                  fpath = os.path.join(root, fname)
                  # Ch·ªâ patch file trong Frameworks/ (dylib th·∫≠t)
                  # B·ªè qua xctest binary trong PlugIns/
                  if "/Frameworks/" not in fpath.replace("\\", "/"):
                      magic = get_macho_info(fpath)
                      if magic is not None:
                          ft_check = struct.unpack_from('<I', open(fpath,'rb').read(16), 12)[0] if magic in (0xfeedfacf, 0xfeedface) else -1
                          if ft_check == 8:
                              print(f"  SKIP (not in Frameworks): {fpath}")
                      continue
                  magic = get_macho_info(fpath)
                  if magic is not None:
                      if patch_bundle_to_dylib(fpath):
                          total_patched += 1

          print(f"\nTotal binaries patched: {total_patched}")
          PYEOF

          # === Fakesign all binaries with ldid ===
          echo "=== Installing ldid ==="
          brew install ldid 2>/dev/null || true

          echo "=== Fakesigning binaries with TrollStore entitlements ==="
          ENTITLEMENTS="resources/entitlements.plist"
          if [ ! -f "$ENTITLEMENTS" ]; then
            echo "WARNING: entitlements.plist not found, using empty signature"
            ENTITLEMENTS=""
          fi
          find Payload -type f | while read f; do
            if file "$f" | grep -q "Mach-O"; then
              echo "Signing: $f"
              if [ -n "$ENTITLEMENTS" ]; then
                ldid -S"$ENTITLEMENTS" "$f" 2>/dev/null || echo "  WARNING: ldid failed on $f"
              else
                ldid -S "$f" 2>/dev/null || echo "  WARNING: ldid failed on $f"
              fi
            fi
          done

          # === Verify all binaries ===
          echo "=== Final verification ==="
          find Payload -type f | while read f; do
            if file "$f" | grep -q "Mach-O"; then
              echo "OK: $f"
            fi
          done

          # === Auth status ===
          if [ "$AUTH_ENABLED" = "true" ]; then
            echo "üîê IPA built WITH IPC Auth Guard"
          else
            echo "‚ö†Ô∏è IPA built WITHOUT auth protection"
          fi

          # === Create IPA ===
          zip -r "WDA_PATH.ipa" Payload/
          echo "=== IPA created ==="
          ls -lh WDA_PATH.ipa

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: WDA-PATH-IPA
          path: WDA_PATH.ipa
          retention-days: 90
